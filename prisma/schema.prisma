generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ------------------------- Enums Globais -------------------------
 */

// Papel GLOBAL, para administração da plataforma
enum SystemRole {
  SUPERADMIN // pode criar/editar tenants e gerenciar contas
  SUPPORT    // opcional, suporte limitado
  NONE       // padrão para usuários comuns
}

enum TenantRole {
  ADMIN     // dono/administrador do restaurante
  MODERATOR // gerente/financeiro
  USER      // atendente/garçom
}

enum OrderStatus {
  OPEN
  CLOSED
  CANCELED
}

/**
 * Itens do pedido: ciclo de vida por item
 * STAGED (carrinho) -> FIRED (produzindo) -> CLOSED (fechar)| VOID (cancelar)
 */
enum OrderItemStatus {
  STAGED
  FIRED
  CLOSED
  VOID
}

enum PaymentMethod {
  CASH
  CARD
  PIX
  VOUCHER
  OTHER
}

enum PaymentStatus {
  PENDING
  AUTHORIZED
  CAPTURED
  REFUNDED
  CANCELED
}

enum PaymentTransactionType {
  AUTHORIZE
  CAPTURE
  REFUND
  CANCEL
  VOID
}

enum PaymentIntentStatus {
  OPEN
  COMPLETED
  CANCELED
}

enum PaymentAttemptStatus {
  INIT
  AUTHORIZED
  CAPTURED
  FAILED
}

enum PixChargeStatus {
  PENDING
  PAID
  EXPIRED
  CANCELED
}

enum InventoryUnit {
  ML
  L
  UNIT
}

enum StockMovementType {
  SALE
  PURCHASE
  ADJUSTMENT
}

enum TransactionType {
  ENTRY
  EXIT
  SANGRIA
  OTHER
}

/**
 * (Opcional) roteamento de produção por estação
 */
enum PrepStation {
  KITCHEN
  BAR
  DESSERT
  OTHER
}

enum IdempotencyStatus {
  PROCESSING
  SUCCEEDED
  FAILED
  EXPIRED
}

enum WebhookDeliveryStatus {
  PENDING
  SENDING
  SENT
  FAILED
}

/**
 * ------------------------- Multi-tenant -------------------------
 */

model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships UserTenant[]
  categories  Category[]
  products    Product[]
  sales       Sale[]
  financials  FinancialTransaction[]

  // Orders & Estoque
  orders         Order[]
  orderItems     OrderItem[]
  payments       Payment[]
  inventoryItems InventoryItem[]
  recipes        Recipe[]
  stockMovements StockMovement[]

  // Pagamentos — entidades auxiliares
  paymentIntents  PaymentIntent[]
  paymentAttempts PaymentAttempt[]
  pixCharges      PixCharge[]

  // 🔽 Back-relations para eventos/auditoria
  orderEvents     OrderEvent[]
  orderItemEvents OrderItemEvent[]

  // Webhooks
  webhookEndpoints  WebhookEndpoint[] @relation("TenantWebhookEndpoint")
  webhookEvents     WebhookEvent[]    @relation("TenantWebhookEvent")
  webhookDeliveries WebhookDelivery[]

  // ------------------------- Caixa (Cash Management) -------------------------
  cashSessions  CashSession[]
  cashMovements CashMovement[]
  cashCounts    CashCount[]
}

model User {
  id         String     @id @default(uuid())
  name       String
  email      String     @unique
  password   String
  active     Boolean    @default(true)
  systemRole SystemRole @default(NONE)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  memberships           UserTenant[]
  financialTransactions FinancialTransaction[] @relation("UserFinancialTransactions")
  sales                 Sale[]

  // Relações com pedidos
  cashierOrders  Order[] @relation("OrderCashierUser")
  createdOrders  Order[] @relation("OrderCreatedByUser")
  assignedOrders Order[] @relation("OrderAssignedToUser")

  // Atores de VOID (itens do pedido)
  voidRequestedItems OrderItem[] @relation("VoidRequestedBy")
  voidApprovedItems  OrderItem[] @relation("VoidApprovedBy")

  // Payments
  createdPayments     Payment[]            @relation("UserCreatedPayments")
  paymentTransactions PaymentTransaction[] @relation("UserPaymentTransactions")

  // Intents criados por este usuário
  createdPaymentIntents PaymentIntent[] @relation("UserCreatedPaymentIntents")

  // 🔽 Back-relations para eventos/auditoria
  orderEvents     OrderEvent[]
  orderItemEvents OrderItemEvent[]
}

model UserTenant {
  // vínculo usuário↔tenant com papel no tenant
  userId   String
  tenantId String
  role     TenantRole @default(USER)

  user   User   @relation(fields: [userId], references: [id])
  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@id([userId, tenantId]) // evita duplicidade de membership
  @@index([tenantId, role])
}

/**
 * ------------------------- Domínio (por tenant) -------------------------
 */

model Category {
  id          String   @id @default(uuid())
  tenantId    String
  name        String
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  parentId String?
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")

  tenant   Tenant    @relation(fields: [tenantId], references: [id])
  products Product[]

  @@unique([tenantId, name])
  @@index([tenantId, name])
  @@map("categories")
}

model Product {
  id          String  @id @default(uuid())
  tenantId    String
  name        String
  description String?
  price       Decimal @db.Decimal(10, 2)
  cost        Decimal @db.Decimal(10, 2)
  barcode     String?
  stock       Int     @default(0) // NOTA: Orders não altera este campo; usa InventoryItem
  isActive    Boolean @default(true)
  prepStation PrepStation?
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant     Tenant      @relation(fields: [tenantId], references: [id])
  saleItems  SaleItem[]
  orderItems OrderItem[]
  recipe     Recipe?

  @@unique([tenantId, name])
  @@unique([tenantId, barcode])
  @@index([tenantId, name])
  @@index([tenantId, barcode])
  @@index([tenantId, prepStation])
  @@map("products")
}

model Sale {
  id        String        @id @default(uuid())
  tenantId  String
  total     Decimal       @db.Decimal(10, 2)
  payment   PaymentMethod
  discount  Decimal?      @db.Decimal(10, 2)
  tax       Decimal?      @db.Decimal(10, 2)
  createdAt DateTime      @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  tenant Tenant     @relation(fields: [tenantId], references: [id])
  items  SaleItem[]
}

model SaleItem {
  id        String  @id @default(uuid())
  saleId    String
  productId String
  quantity  Int
  price     Decimal @db.Decimal(10, 2)

  sale    Sale    @relation(fields: [saleId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

model FinancialTransaction {
  id          String          @id @default(uuid())
  tenantId    String
  type        TransactionType
  amount      Decimal         @db.Decimal(10, 2)
  description String?
  createdAt   DateTime        @default(now())

  createdById String
  createdBy   User   @relation("UserFinancialTransactions", fields: [createdById], references: [id])

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId, type, createdAt])
}

/**
 * ------------------------- Idempotência -------------------------
 */

model IdempotencyKey {
  id                 String            @id @default(uuid())
  tenantId           String
  scope              String // ex.: "orders:create"
  key                String // UUID v4 gerado pelo cliente
  status             IdempotencyStatus @default(PROCESSING)
  requestHash        String
  responseCode       Int?
  responseBody       Json?
  responseTruncated  Boolean           @default(false)
  resourceType       String? // ex.: "order"
  resourceId         String? // id do recurso principal
  errorCode          String?
  errorMessage       String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  expiresAt          DateTime // TTL = now + 48h

  @@unique([tenantId, scope, key], name: "tenantId_scope_key")
  @@index([tenantId, scope])
  @@index([expiresAt])
}

/**
 * ------------------------- Orders e Pagamentos -------------------------
 */

model Order {
  id       String      @id @default(uuid())
  tenantId String
  status   OrderStatus @default(OPEN)

  subtotal Decimal  @db.Decimal(10, 2)
  discount Decimal? @db.Decimal(10, 2)
  total    Decimal  @db.Decimal(10, 2)

  tabNumber      String?
  idempotencyKey String?
  version        Int     @default(0)

  // Atores
  createdByUserId  String
  assignedToUserId String?
  cashierUserId    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Estado financeiro
  isSettled Boolean   @default(false)
  paidAt    DateTime?

  tenant         Tenant @relation(fields: [tenantId], references: [id])
  createdByUser  User   @relation("OrderCreatedByUser", fields: [createdByUserId], references: [id])
  assignedToUser User?  @relation("OrderAssignedToUser", fields: [assignedToUserId], references: [id])
  cashierUser    User?  @relation("OrderCashierUser", fields: [cashierUserId], references: [id])

  items          OrderItem[]
  payments       Payment[]
  stockMovements StockMovement[]

  // intents associados a esta ordem
  paymentIntents PaymentIntent[]

  // 🔽 Back-relations para eventos
  events OrderEvent[]

  @@unique([tenantId, idempotencyKey])
  @@index([tenantId, status, createdAt])
  @@index([tenantId, isSettled, createdAt])
}

model OrderItem {
  id        String @id @default(uuid())
  orderId   String
  tenantId  String
  productId String

  status  OrderItemStatus @default(STAGED)
  station PrepStation?
  closedAt DateTime?

  quantity  Decimal @db.Decimal(10, 3)
  unitPrice Decimal @db.Decimal(10, 2)
  total     Decimal @db.Decimal(10, 2)

  notes          String?
  firedAt        DateTime?
  voidedAt       DateTime?
  voidReason     String?
  voidByUserId   String?
  voidApprovedBy String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])
  tenant  Tenant  @relation(fields: [tenantId], references: [id])

  // Relações de auditoria de VOID
  voidByUser         User? @relation("VoidRequestedBy", fields: [voidByUserId], references: [id])
  voidApprovedByUser User? @relation("VoidApprovedBy", fields: [voidApprovedBy], references: [id])

  // 🔽 Back-relations para eventos
  events OrderItemEvent[]
  @@index([tenantId, status, closedAt])
  @@index([tenantId, orderId])
  @@index([tenantId, station, status, firedAt, updatedAt])
  @@index([tenantId, station, status, voidedAt, firedAt, updatedAt], name: "idx_kds_items")
}

model Payment {
  id       String @id @default(uuid())
  orderId  String
  tenantId String

  // vínculo opcional a um intent aberto
  paymentIntentId String?

  method PaymentMethod
  amount Decimal       @db.Decimal(10, 2)
  status PaymentStatus // PENDING | AUTHORIZED | CAPTURED | REFUNDED | CANCELED

  provider      String?
  providerTxnId String?
  metadata      Json?

  createdByUserId String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // ------------------------- Caixa: vínculo opcional a um turno (CashSession) -------------------------
  sessionId String?
  session   CashSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  // Relações
  order     Order  @relation(fields: [orderId], references: [id])
  tenant    Tenant @relation(fields: [tenantId], references: [id])
  createdBy User   @relation("UserCreatedPayments", fields: [createdByUserId], references: [id])

  // relação com Intent
  intent PaymentIntent? @relation(fields: [paymentIntentId], references: [id])

  // Tentativas (ex.: autorizações, callbacks do PSP)
  attempts     PaymentAttempt[]   @relation("Payment_Attempts")
  transactions PaymentTransaction[]

  // De-dupe robusto por evento do PSP
  @@unique([tenantId, provider, providerTxnId])

  // Índices
  @@index([tenantId, orderId, createdAt])
  @@index([tenantId, status])
  @@index([tenantId, sessionId]) // <— para consultas por sessão de caixa
}

model PaymentIntent {
  id              String              @id @default(uuid())
  tenantId        String
  orderId         String
  currency        String              @default("BRL")
  amountDue       Decimal             @db.Decimal(10, 2)
  status          PaymentIntentStatus @default(OPEN)
  expiresAt       DateTime?
  createdByUserId String
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  tenant    Tenant @relation(fields: [tenantId], references: [id])
  order     Order  @relation(fields: [orderId], references: [id])
  createdBy User   @relation("UserCreatedPaymentIntents", fields: [createdByUserId], references: [id])

  payments  Payment[]
  pixCharges PixCharge[] @relation("Intent_PixCharges")

  @@index([tenantId, orderId, status])
}

model PaymentAttempt {
  id            String               @id @default(uuid())
  tenantId      String
  paymentId     String
  provider      String
  providerTxnId String
  status        PaymentAttemptStatus @default(INIT)
  errorCode     String?
  errorMessage  String?
  raw           Json?
  createdAt     DateTime             @default(now())

  tenant  Tenant  @relation(fields: [tenantId], references: [id])
  payment Payment @relation("Payment_Attempts", fields: [paymentId], references: [id])

  @@unique([tenantId, provider, providerTxnId])
  @@index([tenantId, paymentId, status])
  @@map("payment_attempts")
}

model WebhookEndpoint {
  id        String   @id @default(uuid())
  tenantId  String
  url       String
  secret    String
  events    String[]
  isActive  Boolean  @default(true)
  version   Int      @default(0)         // <— para ETag/If-Match
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant     Tenant           @relation("TenantWebhookEndpoint", fields: [tenantId], references: [id])
  deliveries WebhookDelivery[]

  @@index([tenantId, isActive])
  @@map("webhook_endpoints")
}

model WebhookEvent {
  id         String   @id @default(uuid())
  tenantId   String
  type       String
  payload    Json
  occurredAt DateTime
  version    Int
  createdAt  DateTime @default(now())

  tenant     Tenant           @relation("TenantWebhookEvent", fields: [tenantId], references: [id])
  deliveries WebhookDelivery[]

  @@index([tenantId, createdAt])
  @@index([tenantId, type, occurredAt])
  @@map("webhook_events")
}

model WebhookDelivery {
  id             String                @id @default(uuid())
  tenantId       String
  eventId        String
  endpointId     String
  status         WebhookDeliveryStatus @default(PENDING)
  attemptCount   Int                   @default(0)
  lastError      String?
  responseCode   Int?
  responseTimeMs Int?
  nextRetryAt    DateTime?
  deliveredAt    DateTime?
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt

  tenant   Tenant          @relation(fields: [tenantId], references: [id])
  event    WebhookEvent    @relation(fields: [eventId], references: [id])
  endpoint WebhookEndpoint @relation(fields: [endpointId], references: [id])

  @@index([tenantId, status, nextRetryAt])
  @@index([tenantId, createdAt, status])
  @@index([tenantId, endpointId, status])
  @@index([tenantId, eventId])
  @@map("webhook_deliveries")
}

model PixCharge {
  id              String          @id @default(uuid())
  tenantId        String
  paymentIntentId String
  qrData          String
  emv             String?
  expiresAt       DateTime
  status          PixChargeStatus @default(PENDING)
  provider        String?
  providerTxnId   String?
  createdAt       DateTime        @default(now())

  tenant Tenant        @relation(fields: [tenantId], references: [id])
  intent PaymentIntent @relation("Intent_PixCharges", fields: [paymentIntentId], references: [id])

  @@index([tenantId, paymentIntentId, status])
  @@map("pix_charges")
}

model PaymentTransaction {
  id        String                 @id @default(uuid())
  tenantId  String
  paymentId String
  type      PaymentTransactionType
  amount    Decimal                @db.Decimal(10, 2)
  reason    String?
  byUserId  String
  createdAt DateTime               @default(now())

  // Relações
  payment Payment @relation(fields: [paymentId], references: [id])
  byUser  User    @relation("UserPaymentTransactions", fields: [byUserId], references: [id])

  // Índices
  @@index([tenantId, createdAt])
  @@index([tenantId, type])
}

/**
 * ------------------------- Estoque, Receita e Movimentação -------------------------
 */

model InventoryItem {
  id           String        @id @default(uuid())
  tenantId     String
  name         String
  unit         InventoryUnit
  factorToBase Decimal       @db.Decimal(10, 3)
  onHand       Decimal       @db.Decimal(10, 3)
  isIngredient Boolean       @default(false)

  tenant         Tenant          @relation(fields: [tenantId], references: [id])
  recipeLines    RecipeLine[]
  stockMovements StockMovement[]

  @@unique([tenantId, name])
}

model Recipe {
  id        String @id @default(uuid())
  productId String @unique
  tenantId  String

  product Product      @relation(fields: [productId], references: [id])
  tenant  Tenant       @relation(fields: [tenantId], references: [id])
  lines   RecipeLine[]
}

model RecipeLine {
  id              String  @id @default(uuid())
  recipeId        String
  inventoryItemId String
  qtyBase         Decimal @db.Decimal(10, 3)

  recipe        Recipe        @relation(fields: [recipeId], references: [id])
  inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id])
}

model StockMovement {
  id              String            @id @default(uuid())
  tenantId        String
  inventoryItemId String
  type            StockMovementType
  qtyDelta        Decimal           @db.Decimal(10, 3) // negativo = saída (SALE/fire); positivo = entrada (ADJUSTMENT/void)
  relatedOrderId  String?
  reason          String? // opcional para rastreabilidade
  createdAt       DateTime          @default(now())

  tenant        Tenant        @relation(fields: [tenantId], references: [id])
  inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id])
  order         Order?        @relation(fields: [relatedOrderId], references: [id])

  @@index([tenantId, inventoryItemId, createdAt])
}

/**
 * ------------------------- Auditoria de Orders/Items -------------------------
 */

model OrderEvent {
  id         String      @id @default(uuid())
  tenantId   String
  orderId    String
  userId     String
  eventType  String // e.g. CREATED, STATUS_CHANGE, CANCELED, CLOSED
  fromStatus OrderStatus?
  toStatus   OrderStatus?
  reason     String?
  createdAt  DateTime    @default(now())

  order  Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@index([tenantId, orderId, createdAt])
}

model OrderItemEvent {
  id          String           @id @default(uuid())
  tenantId    String
  orderItemId String
  userId      String
  eventType   String // e.g. CREATED, STATUS_CHANGE, VOID, FIRED, CLOSED
  fromStatus  OrderItemStatus?
  toStatus    OrderItemStatus?
  reason      String?
  createdAt   DateTime         @default(now())

  orderItem OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  tenant    Tenant    @relation(fields: [tenantId], references: [id])
  user      User      @relation(fields: [userId], references: [id])

  @@index([tenantId, orderItemId, createdAt])
}

/**
 * ------------------------- Caixa (Cash Management) -------------------------
 */

enum CashSessionStatus {
  OPEN
  CLOSED
}

enum CashMovementType {
  SUPRIMENTO
  SANGRIA
}

enum CashCountKind {
  PARTIAL
  FINAL
}

model CashSession {
  id             String            @id @default(uuid())
  tenantId       String
  stationId      String
  openedByUserId String
  openedAt       DateTime          @default(now())
  closedAt       DateTime?
  status         CashSessionStatus @default(OPEN)

  // JSONs de agregados/sumários (mantidos como stringified decimals no service)
  openingFloat   Json              // { "CASH": "150.00" }
  totalsByMethod Json              @default("{}") // { "CASH": "...", "CARD": "...", "PIX": "..." }
  paymentsCount  Json              @default("{}") // { "CASH": n, "CARD": n, "PIX": n, "total": n }

  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 🔽 NOVO: sentinela para unicidade de sessão OPEN por estação
  openStationKey String? // = stationId quando OPEN; NULL quando CLOSED

  tenant    Tenant       @relation(fields: [tenantId], references: [id])
  movements CashMovement[]
  counts    CashCount[]
  payments  Payment[]    // back-relation de Payment.sessionId

  @@index([tenantId, stationId, status])
  @@index([tenantId, openedAt])

  // 🔒 Garante “1 OPEN por estação/tenant” sem índice parcial
  @@unique([tenantId, openStationKey])
}

model CashMovement {
  id              String           @id @default(uuid())
  tenantId        String
  sessionId       String
  type            CashMovementType
  method          PaymentMethod    // Negócio restringe a CASH (validado na aplicação)
  amount          Decimal          @db.Decimal(10, 2)
  reason          String?
  createdByUserId String
  createdAt       DateTime         @default(now())

  tenant  Tenant      @relation(fields: [tenantId], references: [id])
  session CashSession @relation(fields: [sessionId], references: [id], onDelete: Restrict)

  @@index([tenantId, sessionId, createdAt])
}

model CashCount {
  id              String        @id @default(uuid())
  tenantId        String
  sessionId       String
  kind            CashCountKind
  denominations   Json          // {"0.05":10, "2":12, "50":3}
  total           Decimal       @db.Decimal(10, 2)
  countedByUserId String
  createdAt       DateTime      @default(now())

  tenant  Tenant      @relation(fields: [tenantId], references: [id])
  session CashSession @relation(fields: [sessionId], references: [id], onDelete: Restrict)

  @@index([tenantId, sessionId, createdAt])
}
